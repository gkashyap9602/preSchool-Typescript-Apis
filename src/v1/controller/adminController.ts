// import mongoose from "mongoose"
import express, { Response, Request, NextFunction } from "express";
import { AdminModels } from "../../models/index";
import { userInterface } from "../../models/adminModel/ModelNewUser";
import { MESSAGES } from "../../utils/message";
import bcrypt from "bcrypt";
import http from "http-status-codes";
import Services from "../../services/index"
import { genAuthToken, random_Otpfun } from "../../utils/auth";
import {
	error_Object,
	resp_Object,
	responseType,
	Ilogin,
} from "../../utils/helperFun";
import {
	Controller,
	Route,
	Get,
	Post,
	Put,
	Delete,
	Tags,
	Body,
	Security,
	Example,
} from "tsoa";

let refreshTokens: any = [];

@Tags("Admin")
@Route("/admin")
export class AdminController extends Controller {
	req: Request;
	res: Response;
	userId: string;
	userRole: number;
	constructor(req: Request, res: Response) {
		super();
		this.req = req;
		this.res = res;
		this.userId = req.body.user ? req.body.user._id : "";
		this.userRole = req.body.user ? req.body.user.role : null;
	};
	
	@Post("/user/create")
	public async New_Users(
		@Body()
		request: {
			role: number;
			fname: string;
			lname: string;
			email: string;
			mobileNum: number;
			password: string;
			gender: string;
			username: string;
			father_name: string;
			mother_name: string;
			religion: string;
		}
	): Promise<responseType | any> {
		try {
			const salt = await bcrypt.genSalt(10);
			const body = request;
			//  logic part of autogenerated username
			const today = new Date();
			const year = today.getFullYear().toString();
			const yearcode = parseInt(year.slice(-2));
			const usercount = await AdminModels.ModelNewUser.find({
				role: 3,
			}).count();
			const count: any = (usercount + 1).toString();
			const usercode = count.padStart(2, 0);
			// check if user alreday exist or not
			const finduser = await AdminModels.ModelNewUser.findOne({
				email: body.email,
			});
			console.log(finduser);
			if (finduser)
				throw new error_Object(
					MESSAGES.USER_ALREADY_REGISTERED,
					http.UNPROCESSABLE_ENTITY
				);
			body.password = await bcrypt.hash(body.password, salt);
			// // const student_img = req.file.path;
			// // Student_Data.student_img = student_img;

			// assigning a auto generated username to the user
			Object.assign(body, { username: "PS" + yearcode + usercode });

			const UserSaved: any = await new AdminModels.ModelNewUser<userInterface>(
				body
			).save(async (err, success) => {

				if (err) throw err
				const mail = await Services.mailer(body.email, "Successfull Registration", `Hello ${success.fname + " " + success.lname} You are Registered Successfully`)
				// console.log(mail,"maill controller side");
				// if(mail.mailError) throw mail.mailError

			});
			return new resp_Object(
				MESSAGES.USER_REGISTERED_SUCCESSFULLY,
				http.CREATED,
				UserSaved
			);
		} catch (error: any) {
			return { CatchError: error };
		}
	};

	@Post("/login")
	public async AdminLoginFun(
		@Body() request: { password: string; email: string }
	): Promise<responseType | any> {
		try {
			console.log(request, "request");

			const { email, password } = request;
			console.log(email, password, "email passs");
			// find if user exist or not
			const Userdata = await AdminModels.ModelNewUser.findOne({ email: email });
			if (!Userdata)
				throw new error_Object(MESSAGES.USER_NOT_VALID, http.UNAUTHORIZED);
			const user_id = Userdata._id;

			if (await bcrypt.compare(password, Userdata.password)) {

				if(Userdata.role === 1){
                     //generating jwt token
				const token = genAuthToken(user_id);
				if (!token)
					throw new error_Object(MESSAGES.TOKEN_NOT_GENERATED, http.NOT_FOUND);
				//   console.log(token, "token login side");
				refreshTokens.push(token.refresh_token);

				return new resp_Object(MESSAGES.LOGIN_SUCCESSFULLY, http.ACCEPTED, {
					AccessToken: token.Access_token,
					RefreshToken: token.refresh_token,
				});
				}else{
					throw new error_Object(
						MESSAGES.YOU_ARE_NOT_ADMIN,
						http.UNAUTHORIZED
					);
				}
				
			} else {
				throw new error_Object(
					MESSAGES.PASSWORD_NOT_MATCHED,
					http.UNAUTHORIZED
				);
			}
		} catch (error) {
			return { CatchError: error };
		}
	};

	@Security("Bearer")
	@Put("/user/update/:id")
	public async Update_userfun(
		@Body()
		request: {
			role: number;
			fname: string;
			lname: string;
			email: string;
			mobileNum: number;
			password: string;
			gender: string;
			father_name: string;
			religion: string;
		},
		id: string
	): Promise<responseType | any> {
		try {
			const user_id = id;
			console.log(user_id, "idd");

			const body = request;
			console.log(body, "body or request");

			if (!body)
				throw new error_Object(
					"Something Not Right Data Not Recieved Please Enter Data",
					http.EXPECTATION_FAILED
				);

			const find = await AdminModels.ModelNewUser.findOne({ _id: user_id });
			if (!find)
				throw new error_Object(
					MESSAGES.DOES_NOT_EXIST,
					http.EXPECTATION_FAILED
				);

			const UserUpdated = await AdminModels.ModelNewUser.findByIdAndUpdate(
				user_id,
				body,
				{ new: true }
			);

			return new resp_Object(MESSAGES.UPDATED_SUCCESSFULLY, http.CREATED);
		} catch (error) {
			return { CatchError: error };
		}
	}
	@Security("Bearer")
	@Delete("/user/delete/:id")
	public async Delete_Userfun(id: string): Promise<responseType | any> {
		try {
			const user_id = id;
			console.log(user_id);
			const find = await AdminModels.ModelNewUser.findOne({ _id: user_id });
			if (!find)
				throw new error_Object(
					MESSAGES.DOES_NOT_EXIST,
					http.EXPECTATION_FAILED
				);

			const deleted = await AdminModels.ModelNewUser.findByIdAndDelete(user_id);
			console.log(deleted, "deleted");
			return new resp_Object(MESSAGES.DELETED_SUCCESSFULLY, http.ACCEPTED);
		} catch (error) {
			return { CatchError: error };
		}
	};
	@Security("Bearer")
	@Get("/users")
	public async User_detailsfun(): Promise<responseType | any> {
		try {
			console.log(this.userId, "userid token ");
			const users_details = await AdminModels.ModelNewUser.find(
				{ role: 3 },
				"father_name mobileNum fname gender"
			);

			return new resp_Object(
				MESSAGES.DATA_RETREIVE_SUCCESSFULLY,
				http.OK,
				users_details
			);
		} catch (error) {
			return { CatchError: error };
		}
	};


	// @Security("Bearer")
	// @Get("/users/{id}")
	// public async SingleUserDetail(paramsId:string) {
	//  try {
	//   const user_id = paramsId
	//   const userdata = await AdminModels.ModelNewUser.find(
	//     { _id: user_id },
	//     { password: 0 }
	//   );
	//   const response = new resp_Object(
	//     MESSAGES.DATA_RETREIVE_SUCCESSFULLY,
	//     http.OK,
	//     userdata
	//   );
	//   return { CatchResponse: response };
	// } catch (error) {
	//   return { CatchError: error };
	// }

	// };
//--------------class functions-------------------------------
@Security("Bearer")
@Post("/class/create")
public async addCourse(
  @Body()
  request: {
	Class: number;
	Class_Code: string;
	Admission_Fee: number;
	Monthly_Fee : number;
  }
): Promise<responseType | any> {
  try {
	
	let Class_Data = request;
    const FindClass = await AdminModels.ModelNewCource.findOne({ Class: Class_Data.Class});
    if (FindClass) throw new error_Object(MESSAGES.CLASS_ALREADY_REGISTERED,http.CONFLICT)

    const ClassRegistered = await new AdminModels.ModelNewCource(Class_Data).save();
	
	return new resp_Object(MESSAGES.CLASS_REGISTERED_SUCCESSFULLY , http.CREATED)
  } catch (error) {
	return { CatchError: error };
  }
};

@Security("Bearer")
@Put("class/update/:id")
  public async updateClass(
    @Body()
    request: {
      Class: number;
      Admission_Fee: number;
      Class_Code: string;
      Monthly_Fee: number;
    },
    id:string
  ): Promise<responseType | any> {
    try {
      const updates = request;
      const options = { new: true };
      const result = await AdminModels.ModelNewCource.findByIdAndUpdate(id, updates, options);
      if (!result) throw new error_Object(MESSAGES.DOES_NOT_EXIST, http.NOT_FOUND);
    
      return new resp_Object(MESSAGES.CLASS_UPDATED_SUCCESSFULLY,http.NO_CONTENT, result);
    } catch (error) {
      return { CatchError: error };
    }
  };

  @Security('Bearer')
  @Delete('/class/delete/:id')
  public async deleteClass(id: string): Promise<responseType | any> {
    try {
      const data = await AdminModels.ModelNewCource.deleteOne({ _id: id });
	  console.log(data,"data..");
      if (!data) throw new error_Object(MESSAGES.DOES_NOT_EXIST,http.BAD_REQUEST);
      return new resp_Object(MESSAGES.DELETED_SUCCESSFULLY,http.NO_CONTENT);
    } catch (error) {
      return { CatchError: error };
    }
  };

  @Security('Bearer')
  @Get('/classes')
  public async get_classes():Promise<responseType | any>{
	try {
		const get_classes = await AdminModels.ModelNewCource.find({},{ addmission_fee: 0, monthly_fee: 0 });
	
     	return new resp_Object(MESSAGES.DATA_RETREIVE_SUCCESSFULLY,http.OK,get_classes)
		
	  } catch (error) {
		return {CatchError:error}
	  }
  };


};
